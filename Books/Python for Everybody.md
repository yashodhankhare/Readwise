---
tags:
  - readwise
---

# Python for Everybody

![rw-book-cover](https://images-na.ssl-images-amazon.com/images/I/51lpFL7BFZL._SL200_.jpg)

## Metadata
- Author: [[Charles Severance]]
- Full Title: Python for Everybody
- Category: #books

## Highlights
- In a sense, you need two skills to be a programmer: First, you need to know the programming language (Python) - you need to know the vocabulary and the grammar. You need to be able to spell the words in this new language properly and know how to construct well-formed "sentences" in this new language. Second, you need to "tell a story". In writing a story, you combine words and sentences to convey an idea to the reader. There is a skill and art in constructing the story, and skill in story writing is improved by doing some writing and getting some feedback. In programming, our program is the "story" and the problem you are trying to solve is the "idea". Once you learn one programming language such as Python, you will find it much easier to learn a second programming language such as JavaScript or C++. The new programming language has very different vocabulary and grammar but the problem-solving skills will be the same across all programming languages. You will learn the "vocabulary" and "sentences" of Python pretty quickly. It will take longer for you to be able to write a coherent program to solve a brand-new problem. We teach programming much like we teach writing. We start reading and explaining programs, then we write simple programs, and then we write increasingly complex programs over time. At some point you "get your muse" and see the patterns on your own and can see more naturally how to take a problem and write a program that solves that problem. And once you get to that point, programming becomes a very pleasant and creative process. ([Location 53](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=53))
    - Tags: [[pink]] 
- The reserved words in the language where humans talk to Python include the following: and       del       global      not       with as        elif      if          or        yield assert    else      import      pass       break     except    in          raise class     finally   is          return continue  for       lambda      try def       from      nonlocal    while ([Location 74](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=74))
    - Tags: [[pink]] 
- We will learn these reserved words and how they are used in good time, but for now we will focus on the Python equivalent of "speak" (in human-to-dog language). The nice thing about telling Python to speak is that we can even tell it what to say by giving it a message in quotes: print('Hello world!') And we have even written our first syntactically correct Python sentence. Our sentence starts with the ([Location 81](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=81))
    - Tags: [[pink]] 
- function print followed by a string of text of our choosing enclosed in single quotes. The strings in the print statements are enclosed in quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string. ([Location 85](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=85))
    - Tags: [[pink]] 
- The proper way to say "good-bye" to Python is to enter quit() at the interactive chevron >>> prompt. It would have probably taken you quite a while to guess that one, so having a book handy probably will turn out to be helpful. ([Location 132](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=132))
    - Tags: [[pink]] 
- The CPU understands a language we call machine language. Machine language is very simple and frankly very tiresome to write because it is represented all in zeros and ones: 001010001110100100101010000001111 11100110000011101010010101101101 ... Machine language seems quite simple on the surface, given that there are only zeros and ones, but its syntax is even more complex and far more intricate than Python. So very few programmers ever write machine language. Instead we build various translators to allow programmers to write in high-level languages like Python or JavaScript and these translators convert the programs to machine language for actual execution by the CPU. Since machine language is tied to the computer hardware, machine language is not portable across different types of hardware. Programs written in high-level languages can be moved between different computers by using a different interpreter on the new machine or recompiling the code to create a machine language version of the program for the new machine. These programming language translators fall into two general categories: (1) interpreters and (2) compilers. An interpreter reads the source code of the program as written by the programmer, parses the source code, and interprets the instructions on the fly. Python is an interpreter and when we are running Python interactively, we can type a line of Python (a sentence) and Python processes it immediately and is ready for us to type another line of Python. Some of the lines of Python tell Python that you want it to remember some value for later. We need to pick a name for that value to be remembered and we can use that symbolic name to retrieve the value later. We use the term variable to refer to the labels we use to refer to this stored data. ([Location 137](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=137))
    - Tags: [[pink]] 
- It is the nature of an interpreter to be able to have an interactive conversation as shown above. A compiler needs to be handed the entire program in a file, and then it runs a process to translate the high-level source code into machine language and then the compiler puts the resulting machine language into a file for later execution. If you have a Windows system, often these executable machine language programs have a suffix of ".exe" or ".dll" which stand for "executable" and "dynamic link library" respectively. In Linux and Macintosh, there is no suffix that uniquely marks a file as executable. ([Location 158](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=158))
    - Tags: [[pink]] 
- When we want to write a program, we use a text editor to write the Python instructions into a file, which is called a script. By convention, Python scripts have names that end with .py. ([Location 177](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=177))
    - Tags: [[pink]] 
- The definition of a program at its most basic is a sequence of Python statements that have been crafted to do something. Even our simple hello.py script is a program. It is a one-line program and is not particularly useful, but in the strictest definition, it is a Python program. It might be easiest to understand what a program is by thinking about a problem that a program might be built to solve, and then looking at a program that would solve that problem. ([Location 186](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=186))
    - Tags: [[pink]] 
- As your programs become increasingly sophisticated, you will encounter three general types of errors: Syntax errors These are the first errors you will make and the easiest to fix. A syntax error means that you have violated the "grammar" rules of Python. Python does its best to point right at the line and character where it noticed it was confused. The only tricky bit of syntax errors is that sometimes the mistake that needs fixing is actually earlier in the program than where Python noticed it was confused. So the line and character that Python indicates in a syntax error may just be a starting point for your investigation. Logic errors A logic error is when your program has good syntax but there is a mistake in the order of the statements or perhaps a mistake in how the statements relate to one another. A good example of a logic error might be, "take a drink from your water bottle, put it in your backpack, walk to the library, and then put the top back on the bottle." Semantic errors A semantic error is when your description of the steps to take is syntactically perfect and in the right order, but there is simply a mistake in the program. The program is perfectly correct but it does not do what you intended for it to do. A simple example would be if you were giving a person directions to a restaurant and said, "...when you reach the intersection with the gas station, turn left and go one mile and the restaurant is a red building on your left." Your friend is very late and calls you to tell you ([Location 247](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=247))
    - Tags: [[pink]] 
- that they are on a farm and walking around behind a barn, with no sign of a restaurant. Then you say "did you turn left or right at the gas station?" and they say, "I followed your directions perfectly, I have them written down, it says turn left and go one mile at the gas station." Then you say, "I am very sorry, because while my instructions were syntactically correct, they sadly contained a small but undetected semantic error.". Again in all three types of errors, Python is merely trying its hardest to do exactly what you have asked. ([Location 258](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=258))
    - Tags: [[pink]] 
- If something seems particularly hard, there is usually no value in staying up all night and staring at it. Take a break, take a nap, have a snack, explain what you are having a problem with to someone (or perhaps your dog), and then come back to it with fresh eyes. I assure you that once you learn the programming concepts in the book you will look back and see that it was all really easy and elegant and it simply took you a bit of time to absorb it. ([Location 296](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=296))
    - Tags: [[pink]] 
- Variable names can be arbitrarily long. They can contain both letters and numbers, but they cannot start with a number. It is legal to use uppercase letters, but it is a good idea to begin variable names with a lowercase letter (you'll see why later). The underscore character ( _ ) can appear in a name. It is often used in names with multiple words, such as my_name or airspeed_of_unladen_swallow. Variable names can start with an underscore character, but we generally avoid doing this unless we are writing library code for others to use. ([Location 374](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=374))
    - Tags: [[pink]] 
- Python reserves 33 keywords: and       del       from      None      True as        elif      global    nonlocal  try assert    else      if        not       while break     except    import    or        with class     False     in        pass      yield continue  finally   is        raise def       for       lambda    return ([Location 387](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=387))
    - Tags: [[pink]] 
- Expressions An expression is a combination of values, variables, and operators. A value all by itself is considered an expression, and so is a variable, so the following are all legal expressions (assuming that the variable x has been assigned a value): 17 x x + 17 If you type an expression in interactive mode, the interpreter evaluates it and displays the result: >>> 1 + 1 2 But in a script, an expression all by itself doesn't do anything! This is a common source of confusion for beginners. ([Location 417](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=417))
    - Tags: [[pink]] 
- When more than one operator appears in an expression, the order of evaluation depends on the rules of precedence. For mathematical operators, Python follows mathematical convention. The acronym PEMDAS is a useful way to remember the rules: Parentheses have the highest precedence and can be used to force an expression to evaluate in the order you want. Since expressions in parentheses are evaluated first, 2 * (3-1) is 4, and (1+1)**(5-2) is 8. You can also use parentheses to make an expression easier to read, as in (minute * 100) / 60, even if it doesn't change the result. Exponentiation has the next highest precedence, so 2**1+1 is 3, not 4, and 3*1**3 is 3, not 27. Multiplication and Division have the same precedence, which is higher than Addition and Subtraction, which also have the same precedence. So 2*3-1 is 5, not 4, and 6+4/2 is 8, not 5. ([Location 427](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=427))
    - Tags: [[pink]] 
- Operators with the same precedence are evaluated from left to right. So the expression 5-3-1 is 1, not 3, because the 5-3 happens first and then 1 is subtracted from 2. When in doubt, always put parentheses in your expressions to make sure the computations are performed in the order you intend. ([Location 436](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=436))
    - Tags: [[pink]] 
- The modulus operator turns out to be surprisingly useful. For example, you can check whether one number is divisible by another: if x % y is zero, then x is divisible by y. You can also extract the right-most digit or digits from a number. For example, x % 10 yields the right-most digit of x (in base 10). Similarly, x % 100 yields the last two digits. ([Location 446](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=446))
    - Tags: [[pink]] 
- String operations The + operator works with strings, but it is not addition in the mathematical sense. Instead it performs concatenation, which means joining the strings by linking them end to end. For example: >>> first = 10 >>> second = 15 >>> print(first+second) 25 >>> first = '100' >>> second = '150' >>> print(first + second) 100150 The * operator also works with strings by multiplying the content of a string by an integer. For example: ([Location 451](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=451))
    - Tags: [[pink]] 
- Asking the user for input Sometimes we would like to take the value for a variable from the user via their keyboard. Python provides a built-in function called input that gets input from the keyboard1. When this function is called, the program stops and waits for the user to type something. When the user presses Return or Enter, the program resumes and input returns what the user typed as a string. >>> inp = input() Some silly stuff >>> print(inp) Some silly stuff Before getting input from the user, it is a good idea to print a prompt telling the user what to input.… ([Location 461](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=461))
    - Tags: [[pink]] 
- The sequence \n at the end of the prompt represents a newline, which is a special character that causes a line break. That's why the user's input appears below the prompt. If you expect the user to type an integer, you can try to convert the return value to int using the int() function: >>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n' >>> speed = input(prompt) What...is the airspeed velocity of an unladen swallow? 17 >>> int(speed) 17 >>> int(speed) + 5 22 But if the user types something other than a string of digits, you get an error: >>> speed = input(prompt) What...is the airspeed velocity of an unladen swallow? What… ([Location 473](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=473))
    - Tags: [[pink]] 
- Comments As programs get bigger and more complicated, they get more difficult to read. Formal languages are dense, and it is often difficult to look at a piece of code and figure out what it is doing, or why. For this reason, it is a good idea to add notes to your programs to explain in natural language what the program is doing. These notes are called comments, and in Python they start with the # symbol: # compute the percentage of the hour that has elapsed percentage = (… ([Location 485](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=485))
    - Tags: [[pink]] 
- percentage = (minute * 100) / 60     # percentage of an hour Everything from the # to the end of the line is ignored; it has no effect on the program. Comments are most useful when they document non-obvious features of the code. It is reasonable to assume that the reader can figure out what the code does; it is much more useful to explain why. This comment is redundant with the code and useless: v = 5     # assign 5 to v This comment contains useful information that is not in the code: v = 5     # velocity in meters/second.… ([Location 492](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=492))
    - Tags: [[pink]] 
- As long as you follow the simple rules of variable naming, and avoid reserved words, you have a lot of choice when you name your variables. In the beginning, this choice can be confusing both when you read a program and when you write your own programs. For example, the following three programs are identical in terms of what… ([Location 501](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=501))
    - Tags: [[pink]] 
- We call these wisely chosen variable names "mnemonic variable names". The word mnemonic2 means "memory aid". We choose mnemonic variable names to help us remember why we created the variable in the first place. ([Location 513](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=513))
    - Tags: [[pink]] 
- The parts of the code that are defined by Python (for, in, print, and :) are in bold and the programmer-chosen variables (word and words) are not in bold. Many text editors are aware of Python syntax and will color reserved words differently to give you clues to keep your variables and reserved words separate. After a while you will begin to read Python and quickly determine what is a variable and what is a reserved word. ([Location 532](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=532))
    - Tags: [[pink]] 
- At this point, the syntax error you are most likely to make is an illegal variable name, like class and yield, which are keywords, or odd~job and US$, which contain illegal characters. If you put a space in a variable name, Python thinks it is two operands without an operator: ([Location 538](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=538))
    - Tags: [[pink]] 
- Variables names are case sensitive, so LaTeX is not the same as latex. ([Location 552](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=552))
    - Tags: [[pink]] 
- The == operator is one of the comparison operators; the others are: ([Location 602](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=602))
    - Tags: [[pink]] 
- x != y               # x is not equal to y x > y                # x is greater than y x < y                # x is less than y x >= y               # x is greater than or equal to y x <= y               # x is less than or equal to y x is y               # x is the same as y x is not y           # x is not the same as y Although these operations are probably familiar to you, the Python symbols are different from the mathematical symbols for the same operations. A common error is to use a single equal sign (=) instead of a double equal sign (==). Remember that = is an assignment operator and == is a comparison operator. There is no such thing as =< or =>. ([Location 604](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=604))
    - Tags: [[pink]] 
- There are three logical operators: and, or, and not. The semantics (meaning) of these operators is similar to their meaning in English. ([Location 615](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=615))
    - Tags: [[pink]] 
- Conditional execution In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly. Conditional statements give us this ability. The simplest form is the if statement: ([Location 627](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=627))
    - Tags: [[pink]] 
- The boolean expression after the if statement is called the condition. We end the if statement with a colon character (:) and the line(s) after the if statement are indented. ([Location 631](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=631))
    - Tags: [[pink]] 
- There is no limit on the number of statements that can appear in the body, but there must be at least one. Occasionally, it is useful to have a body with no statements (usually as a place holder for code you haven't written yet). In that case, you can use the pass statement, which does nothing. ([Location 638](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=638))
    - Tags: [[pink]] 
- If you enter an if statement in the Python interpreter, the prompt will change from three chevrons to three dots to indicate you are in the middle of a block of statements, as shown below: >>> x = 3 >>> if x < 10: ...    print('Small') ... Small >>> When using the Python interpreter, you must leave a blank line at the end of a block, otherwise Python will return an error: >>> x = 3 >>> if x < 10: ([Location 642](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=642))
    - Tags: [[pink]] 
- ...    print('Small') ... print('Done')   File "<stdin>", line 3     print('Done')         ^ SyntaxError: invalid syntax A blank line at the end of a block of statements is not necessary when writing and executing… ([Location 649](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=649))
    - Tags: [[pink]] 
- Alternative execution A second form of the if statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this: if x%2 == 0 :     print('x is even') else :     print('x is odd') If the remainder when x is divided by 2 is 0, then we know that x is even, and the program displays a… ([Location 653](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=653))
    - Tags: [[pink]] 
- Since the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called branches, because they are branches in the flow of execution. Chained conditionals Sometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional: if x < y:     print('x… ([Location 660](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=660))
    - Tags: [[pink]] 
- elif is an abbreviation of "else if." Again, exactly one branch will be executed. If-Then-ElseIf Logic There is no limit on the number of elif statements. If there is an else clause, it has to be at the end, but there doesn't have to be one. if choice == 'a':     print('Bad guess') elif choice == 'b':     print('Good guess') elif choice == 'c':     print('Close, but not correct') Each condition… ([Location 667](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=667))
    - Tags: [[pink]] 
- the corresponding branch executes, and the statement ends. Even if more than one condition is true, only the first true branch executes. Nested conditionals One conditional can also be nested within another. We could have written the three-branch example like this: if x == y:     print('x and y are equal') else:     if x < y:         print('x is less than y')     else:         print('x is greater than y') The outer conditional contains two branches. The first branch contains a simple statement. The second branch contains another if statement,… ([Location 675](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=675))
    - Tags: [[pink]] 
- Nested If Statements Although the indentation of the statements makes the structure apparent, nested conditionals become difficult to read very quickly. In general, it is a good idea to avoid them when you can. Logical operators often provide a way to simplify nested conditional statements. For example, we can rewrite the following code using a single conditional: if 0 < x:     if x < 10:         print('x is a positive single-digit number.') The print… ([Location 684](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=684))
    - Tags: [[pink]] 
- if 0 < x and x < 10:     print('x is a positive single-digit number.') Catching exceptions using try and except Earlier we saw a code segment where we used the input and int functions to read and parse an integer number entered by the user. We also saw how treacherous doing this could be: >>> prompt = "What is the air velocity of an unladen swallow?\n" >>> speed = input(prompt) What is the air velocity of an unladen swallow? What do you mean, an African or a European swallow? >>> int(speed) ValueError: invalid literal for int() with base 10: >>> When we are executing these statements in the Python interpreter, we get a new prompt from the interpreter, think "oops", and move on to our next statement. However if you place this code in a Python script and this error occurs, your script immediately stops in its tracks with a traceback. It does not execute the following statement. Here is a sample program to convert a Fahrenheit temperature to a Celsius temperature: inp = input('Enter Fahrenheit Temperature: ') fahr = float(inp) cel = (fahr - 32.0) * 5.0 / 9.0… ([Location 691](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=691))
    - Tags: [[pink]] 
- Traceback (most recent call last):   File "fahren.py", line 2, in <module>     fahr = float(inp) ValueError: could not convert string to float: 'fred' There is a conditional execution structure built into Python to handle these types of expected and unexpected errors called "try / except". The idea of try and except is that you know that some sequence of instruction(s) may have a problem and you want to add some statements to be executed if an error occurs. These extra statements (the except block) are ignored if there is no error. You can think of the try and except feature in Python as an "insurance policy" on a sequence of statements. We can rewrite our temperature converter as… ([Location 710](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=710))
    - Tags: [[pink]] 
- # Code: http://www.py4e.com/code3/fahren2.py Python starts by executing the sequence of statements in the try block. If all goes well, it skips the except block and proceeds. If an exception occurs in the try block, Python jumps out of the try block and executes the sequence of statements in the except block. python fahren2.py Enter Fahrenheit Temperature:72 22.22222222222222 python fahren2.py Enter Fahrenheit Temperature:fred Please enter a number Handling an exception with a try statement is called catching an exception. In this example, the except clause prints an error message. In general, catching an exception gives you a chance to fix… ([Location 722](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=722))
    - Tags: [[pink]] 
- as x >= 2 and (x/y) > 2, it evaluates the expression from left to right. Because of the definition of and, if x is less than 2, the expression x >= 2 is False and so the whole expression is False regardless of whether (x/y) > 2 evaluates to True or False. When Python detects that there is nothing to be gained by evaluating the rest of a logical expression, it stops its evaluation and does not do the computations in the rest of the logical expression. When the evaluation of a logical expression stops because the overall value is already known, it is called short-circuiting the evaluation. While this may seem like a fine point, the short-circuit behavior leads to a clever technique called the guardian… ([Location 732](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=732))
    - Tags: [[pink]] 
- >>> y = 0 >>> x >= 2 and (x/y) > 2 Traceback (most recent call last):   File "<stdin>", line 1, in <module> ZeroDivisionError: division by zero >>> The third calculation failed because Python was evaluating (x/y) and y was zero, which causes a runtime error. But the second example did not fail because the first part of the expression x >= 2 evaluated to False so the (x/y) was not ever executed due to the short-circuit rule and there was no error. We can construct the logical expression to strategically place a guard evaluation just before the evaluation that might cause an error as follows: >>> x = 1 >>> y = 0 >>> x >= 2 and … ([Location 747](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=747))
    - Tags: [[pink]] 
- File "<stdin>", line 1, in <module> ZeroDivisionError: division by zero >>> In the first logical expression, x >= 2 is False so the evaluation stops at the and. In the second logical expression, x >= 2 is True but y != 0 is False so we never reach (x/y). In the third logical expression, the y != 0 is after the (x/y) calculation so the expression fails with an error. In the second… ([Location 764](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=764))
    - Tags: [[pink]] 
- The name of the function is type. The expression in parentheses is called the argument of the function. The argument is a value or variable that we are passing into the function as input to the function. The result, for the type function, is the type of the argument. It is common to say that a function "takes" an argument and "returns" a result. The result is called the return value. ([Location 821](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=821))
    - Tags: [[pink]] 
- Python provides a number of important built-in functions that we can use without needing to provide the function definition. The creators of Python wrote a set of functions to solve common problems and included them in Python for us to use. The max and min functions give us the largest and smallest values in a list, respectively: >>> max('Hello world') 'w' >>> min('Hello world') ' ' >>> The max function tells us the "largest character" in the string (which turns out to be the letter "w") and the min function shows us the smallest character (which turns out to be a space). Another very common built-in function is the len function which tells us how many items are in its argument. If the argument to len is a string, it returns the number of characters in the string. ([Location 825](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=825))
    - Tags: [[pink]] 
- These functions are not limited to looking at strings. They can operate on any set of values, as we will see in later chapters. You should treat the names of built-in functions as reserved words (i.e., avoid using "max" as a variable name). ([Location 837](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=837))
    - Tags: [[pink]] 
- Python also provides built-in functions that convert values from one type to another. The int function takes any value and converts it to an integer, if it can, or complains otherwise: ([Location 839](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=839))
    - Tags: [[pink]] 
- int can convert floating-point values to integers, but it doesn't round off; it chops off the fraction part: ([Location 844](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=844))
    - Tags: [[pink]] 
- float converts integers and strings to floating-point numbers: ([Location 848](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=848))
    - Tags: [[pink]] 
- Python has a math module that provides most of the familiar mathematical functions. Before we can use the module, we have to import it: >>> import math ([Location 854](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=854))
    - Tags: [[pink]] 
- This statement creates a module object named math. If you print the module object, you get some information about it: >>> print(math) <module 'math' (built-in)> The module object contains the functions and variables defined in the module. To access one of the functions, you have to specify the name of the module and the name of the function, separated by a dot (also known as a period). This format is called dot notation. ([Location 857](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=857))
    - Tags: [[pink]] 
- The random module provides functions that generate pseudorandom numbers (which I will simply call "random" from here on). The function random returns a random float between 0.0 and 1.0 (including 0.0 but not 1.0). Each time you call random, you get the next number in a long series. To see a sample, run this loop: import random for i in range(10):     x = random.random()     print(x) This program produces the following list of 10 random numbers between 0.0 and up to but not including 1.0. 0.11132867921152356 0.5950949227890241 0.04820265884996877 ([Location 884](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=884))
    - Tags: [[pink]] 
- 0.841003109276478 0.997914947094958 0.04842330803368111 0.7416295948208405 0.510535245390327 0.27447040171978143 0.028511805472785867 ([Location 891](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=891))
    - Tags: [[pink]] 
- The random function is only one of many functions that handle random numbers. The function randint takes the parameters low and high, and returns an integer between low and high (including both). >>> random.randint(5, 10) 5 >>> random.randint(5, 10) 9 To choose an element from a sequence at random, you can use choice: >>> t = [1, 2, 3] >>> random.choice(t) 2 ([Location 894](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=894))
    - Tags: [[pink]] 
- >>> random.choice(t) 3 The random module also provides functions to generate random values from continuous distributions including Gaussian, exponential, gamma, and a few more. ([Location 903](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=903))
    - Tags: [[pink]] 
- So far, we have only been using the functions that come with Python, but it is also possible to add new functions. A function definition specifies the name of a new function and the sequence of statements that execute when the function is called. Once we define a function, we can reuse the function over and over throughout our program. Here is an example: def print_lyrics():     print("I'm a lumberjack, and I'm okay.")     print('I sleep all night and I work all day.') def is a keyword that indicates that this is a function definition. The name of the function is ([Location 905](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=905))
    - Tags: [[pink]] 
- print_lyrics. The rules for function names are the same as for variable names: letters, numbers and some punctuation marks are legal, but the first character can't be a number. You can't use a keyword as the name of a function, and you should avoid having a variable and a function with the same name. The empty parentheses after the name indicate that this function doesn't take any arguments. Later we will build functions that take arguments as their inputs. The first line of the function definition is called the header; the rest is called the body. The header has to end with a colon and the body has to be indented. By convention, the indentation is always four spaces. The body can contain any number of statements. If you type a function definition in interactive mode, the interpreter prints ellipses (...) to let you know that the definition isn't complete: >>> def print_lyrics(): ...     print("I'm a lumberjack, and I'm okay.") ...     print('I sleep all night and I work all day.') ... ([Location 912](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=912))
    - Tags: [[pink]] 
- Defining a function creates a variable with the same name. ([Location 921](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=921))
    - Tags: [[pink]] 
- Flow of execution In order to ensure that a function is defined before its first use, you have to know the order in which statements are executed, which is called the flow of execution. Execution always begins at the first statement of the program. Statements are executed one at a time, in order from top to bottom. Function definitions do not alter the flow of execution of the program, but remember that statements inside the function are not executed until the function is called. A function call is like a detour in the flow of execution. Instead of going to the next statement, the flow jumps to the body of the function, executes all the statements there, and then comes back to pick up where it left off. That sounds simple enough, until you remember that one function can call another. While in the middle of one function, the program might have to execute the statements in another function. But while executing ([Location 949](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=949))
    - Tags: [[pink]] 
- that new function, the program might have to execute yet another function! Fortunately, Python is good at keeping track of where it is, so each time a function completes, the program picks up where it left off in the function that called it. When it gets to the end of the program, it terminates. What's the moral of this sordid tale? When you read a program, you don't always want to read from top to bottom. Sometimes it makes more sense if you follow the flow of execution. ([Location 956](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=956))
    - Tags: [[pink]] 
- Fruitful functions and void functions Some of the functions we are using, such as the math functions, yield results; for lack of a better name, I call them fruitful functions. Other functions, like print_twice, perform an action but don't return a value. They are called void functions. When you call a fruitful function, you almost always want to do something with the result; for example, ([Location 982](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=982))
    - Tags: [[pink]] 
- Why functions? It may not be clear why it is worth the trouble to divide a program into functions. There are several reasons: Creating a new function gives you an opportunity to name a group of statements, which makes your program easier to read, understand, and debug. Functions can make a program smaller by eliminating repetitive code. Later, if you make a change, you only have to make it in one place. Dividing a long program into functions allows you to debug the parts one at a time and then assemble them into a working whole. Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it. ([Location 1012](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=1012))
    - Tags: [[pink]] 
- Throughout the rest of the book, often we will use a function definition to explain a concept. Part of the skill of creating and using functions is to have a function properly capture an idea such as "find the smallest value in a list of values". Later we will show you code that finds the smallest in a list of values and we will present it to you as a function named min which takes a list of values as its argument and returns the smallest value in the list. ([Location 1017](https://readwise.io/to_kindle?action=open&asin=B01IA5VIFM&location=1017))
    - Tags: [[pink]]

